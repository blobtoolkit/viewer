#!/usr/bin/env node
const doc = `
Usage:
  utils/fetch_targets TAXID
`;

const fetch = require("node-fetch");
const resolve = require("path").resolve;
const docopt = require("docopt").docopt;
const fs = require("fs");

const fetchAsyncText = async (url) => await (await fetch(url)).text();

const countAssemblies = async (root) => {
  let baseUrl = "https://www.ebi.ac.uk/ena/portal/api";
  let url = `${baseUrl}/count?query="tax_tree(${root})"&result=assembly`;
  let text = await fetchAsyncText(url);
  let count = text.match(/[\d,]+/)[0];
  return count.replace(",", "");
};

const listAssemblies = async (root) => {
  let baseUrl = "https://www.ebi.ac.uk/ena/portal/api";
  let fields = "accession,tax_id,sample_accession,assembly_name";
  let url = `${baseUrl}/search?query="tax_tree(${root})"&result=assembly&fields=${fields}&format=json`;
  process.stderr.write(`${url}\n`);
  let assemblies = await fetchAsyncText(url);
  assemblies = JSON.parse(assemblies);
  process.stderr.write(JSON.stringify(assemblies[0]));
  return assemblies;
};

const listWGS = async (root) => {
  let baseUrl = "https://www.ebi.ac.uk/ena/portal/api";
  let fields = "accession,study_accession,sample_accession";
  let url = `${baseUrl}/search?query="tax_tree(${root})"&result=wgs_set&fields=${fields}&format=json`;
  process.stderr.write(`${url}\n`);
  let sets = await fetchAsyncText(url);
  samples = {};
  sets = JSON.parse(sets);
  process.stderr.write(JSON.stringify(sets[0]));
  sets.forEach((set) => {
    samples[set.sample_accession] = set;
  });
  return samples;
};

const hierarchy = [
  "superkingdom",
  "kingdom",
  "phylum",
  "class",
  "order",
  "family",
  "genus",
  "species",
];

let n = 0;
let species = {};
let accessions = {};

const addAssemblyToTree = (taxid, acc, taxdump, tree) => {
  let ancestors = taxdump.ancestors[taxid];
  if (!ancestors) return;
  let spid = ancestors["species"];
  let node = tree;
  node.ta++;
  if (!species[spid]) node.ts++;
  hierarchy.forEach((r) => {
    let ancid = ancestors[r];
    if (ancid > 0) {
      name = taxdump.names[ancid];
    } else {
      name = taxdump.names[-ancid] + "-undef";
    }
    if (!node.d[name]) {
      n++;
      node.d[name] = { n, r, ta: 0, ts: 0, d: {} };
    }
    node = node.d[name];
    node.ta++;
    if (!species[spid]) node.ts++;
  });
  species[spid] = true;
  let taxon_name = taxdump.names[taxid];
  process.stderr.write(`${acc} :: ${spid} :: ${taxon_name}\n`);
  if (taxon_name != taxdump.names[spid]) {
    if (!node.d[taxon_name]) {
      n++;
      node.d[taxon_name] = { n, r: "taxon_name", ta: 0, d: {} };
    }
    node = node.d[taxon_name];
    node.ta++;
  }
  n++;
  node.d[acc] = { n };
};

const main = async (args) => {
  let count = await countAssemblies(args.TAXID);
  process.stderr.write(`Processing ${count} assemblies...\n`);
  let taxids = {};
  let taxdump = JSON.parse(fs.readFileSync(`${__dirname}/taxdump.json`));
  let targets = { n, r: "root", ta: 0, ts: 0, d: {} };
  let ids = {};
  let processed = 0;
  let assemblies = await listAssemblies(args.TAXID);
  let samples = await listWGS(args.TAXID);

  assemblies.forEach((asm) => {
    let taxid = asm.tax_id;
    let acc;
    let id = asm.accession.replace(/\./g, "_");
    if (!ids[id]) {
      ids[id] = true;
      processed += 1;
      if (samples[asm.sample_accession]) {
        acc = samples[asm.sample_accession].accession;
        acc = acc.replace(/0+$/g, "");
      } else if (asm.assembly_name && asm.assembly_name.length > 0) {
        acc = asm.assembly_name.replace(/\./g, "_");
      } else {
        acc = id;
      }
      addAssemblyToTree(taxid, acc, taxdump, targets, n);
    }
  });
  process.stderr.write(`done\n`);
  process.stdout.write(JSON.stringify(targets));
};

const args = docopt(doc);

if (typeof args !== "object") {
  process.stderr.write(doc);
  process.exit(1);
}

main(args);
